type TransformFunction = (key: string) => string;
type ObjectToTransform = Record<string | number, unknown>;
type TransformedObject = Record<string | number, unknown>;
type TransformFunctionPartialParams = [ObjectToTransform, boolean, boolean];
type PartialTransformFunction = (objectToTransform: ObjectToTransform, deep?: boolean, preserve?: boolean) => TransformedObject;
type TransformObjectKeys = (transformFn: TransformFunction, objectToTransform: ObjectToTransform, deep?: boolean, preserve?: boolean) => TransformedObject;
type OmitFunction = (keys: Array<string>, obj: ObjectToTransform) => TransformedObject;
type AnyTransformFunction = PartialTransformFunction | TransformObjectKeys | OmitFunction;
declare const words: (str: string) => Array<string>;
declare const camelCase: (str: string) => string;
declare const snakeCase: (str: string) => string;
declare const kebabCase: (str: string) => string;
declare const isObject: (value: unknown) => boolean;
/**
   * Transforms the keys of an object based on a provided transformation function.
   *
   * @param {TransformFunction} transformFn - The function to transform the object's keys.
   * @param {Record<string | number, unknown>} objectToTransform - The object whose keys are to be transformed.
   * @param {boolean} [deep=false] - Whether to deeply transform nested object keys.
   * @param {boolean} [preserve=false] - Whether to preserve the original object's keys.
   * @return {Record<string | number, unknown>} A new object with transformed keys.
   */
declare const transformObjectKeys: <T = TransformedObject, O = ObjectToTransform>(transformFn: TransformFunction, objectToTransform: O, deep?: boolean, preserve?: boolean) => T;
/**
 * Transforms the keys of an object to camelCase.
 *
 * @param {Record<string | number, unknown>} objectToTransform - The object whose keys are to be transformed.
 * @param {boolean} [deep=false] - Whether to deeply transform nested object keys.
 * @param {boolean} [preserve=false] - Whether to preserve the original object's keys.
 * @return {Record<string | number, unknown>} A new object with camelCased keys.
 */
declare const camelCaseObjectKeys: (...rest: TransformFunctionPartialParams) => TransformedObject;
/**
   * Transforms the keys of an object to snake_case.
   *
   * @param {Record<string | number, unknown>} objectToTransform - The object whose keys are to be transformed.
   * @param {boolean} [deep=false] - Whether to deeply transform nested object keys.
   * @param {boolean} [preserve=false] - Whether to preserve the original object's keys.
   * @return {Record<string | number, unknown>} A new object with snake_cased keys.
   */
declare const snakeCaseObjectKeys: (...rest: TransformFunctionPartialParams) => TransformedObject;
/**
   * Transforms the keys of an object to kebab-case.
   *
   * @param {Record<string | number, unknown>} objectToTransform - The object whose keys are to be transformed.
   * @param {boolean} [deep=false] - Whether to deeply transform nested object keys.
   * @param {boolean} [preserve=false] - Whether to preserve the original object's keys.
   * @return {Record<string | number, unknown>} A new object with kebab-cased keys.
   */
declare const kebabCaseObjectKeys: (...rest: TransformFunctionPartialParams) => TransformedObject;
/**
   * Omit keys from an object.
   *
   * @param {Array<string>} keys - The keys to omit.
   * @param {Record<string | number, unknown>} obj - The object from which to omit keys.
   *
   * @return {Record<string | number, unknown>} A new object with omitted keys.
   */
declare const omit: (keys: Array<string>, obj: ObjectToTransform) => TransformedObject;

export { type AnyTransformFunction, type ObjectToTransform, type OmitFunction, type PartialTransformFunction, type TransformFunction, type TransformFunctionPartialParams, type TransformObjectKeys, type TransformedObject, camelCase, camelCaseObjectKeys, isObject, kebabCase, kebabCaseObjectKeys, omit, snakeCase, snakeCaseObjectKeys, transformObjectKeys, words };
